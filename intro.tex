%% The following is a directive for TeXShop to indicate the main file
%%!TEX root = diss.tex

\chapter{Introduction}
\label{ch:Introduction}

The conversion of signals between analog and digital domanis is an often encountered problem in signal processing. For an analog signal to be represented digitally, it must undergo the processes of sampling and quantization (\autoref{fig:samp-quant}). The former is the conversion from \gls{CT} to \gls{DT} and can be done without loss of information by the Nyquist-Shannon sampling theorem, given a sufficiently high sample rate. The latter is the mapping from an infinite set of possible values to a finite number of quantization levels. Unlike sampling, the process of quantization is non-injective and thus irreversible. The design of signal conversion circuits that minimize the error introduced by quantization is a major problem in mixed signal electronics.

\begin{figure}
	\centering
	\begin{tikzpicture}[ampersand replacement=\&,scale=0.75, every node/.style={scale=0.75}]
	
		\node[coordinate] (w) at (0,0) {};
		\node[coordinate] (n) at (5,1.5) {};
		\node[coordinate] (s) at (5,-1.5) {};
		\node[coordinate] (e) at (8.5,0) {};
		\node[dspsquare] (sh2) at (4,0) {S/H};
		\node[dspsquare] (q2) at (6,0) {\RaisingEdge};
		\node[coordinate] (w-up) at ($(w) + (1,0.5)$) {};
		\node[coordinate] (w-right) at ($(w) + (1.25,0)$) {};
		\node[coordinate] (w-low) at ($(w) + (1,-0.5)$) {};
		\node[coordinate] (n-left) at ($(n) + (-1.5,0)$) {};
		\node[coordinate] (s-left) at  ($(s) + (-1.5,0)$) {};
		\node[coordinate] (n-right) at ($(n) + (1.25,0)$) {};
		\node[coordinate] (s-right) at ($(s) + (1.25,0)$) {};
		\node[coordinate] (mid) at ($(e) + (-1.5,0)$) {};
		\node[coordinate] (e-left) at ($(e) + (-1.5,0)$) {};
		
		\path (w-up) -- (n-left) node[dspsquare,midway,sloped] (sh1) {S/H};
		\path (w-up) -- (n-left) node[midway,sloped,yshift=20] {Sampling};
		\path (w-low) -- (s-left) node[dspsquare,midway,sloped] (q1) {\RaisingEdge};
		\path (w-low) -- (s-left) node[midway,sloped,yshift=-20] {Quantization};
		
		\draw[conndspconn] (w-up) -- (sh1);
		\draw[dspconn] (w-low) -- (q1);
		\draw[conndspconn] (sh1) -- (n-left);
		\draw[dspconn] (q1) -- (s-left);		
		\draw[conndspconn] (w-right) -- (sh2);
		\draw[conndspconn] (sh2) -- (q2);
		\draw[dspconn] (q2) -- (mid);
		
		% Analog signal.
		\begin{axis}[
			at={(w)},
			anchor=center,
			grid=major, 
			x=14mm, y=7mm, 
			axis x line=center, axis y line*=left, 
			ymin=-1, ymax=1, 
			yticklabels={}, xticklabels={},
			xlabel={$t$}, ylabel={$r(t)$},
			every axis x label/.style={
				at={(ticklabel* cs:1.05)},
				anchor=west
				},
			every axis y label/.style={
				at={(ticklabel* cs:0.5)},
				anchor=south,
				rotate=90
				},
			]
		\addplot[domain=-0:1,  smooth,  black]
		  plot {sin(deg(2*pi*1.33*x))};
		\end{axis}
		
		% Sampled plot.
		\begin{axis}[
			at={(n)},
			anchor=center,
			grid=major, 
			x=14mm, y=7mm, 
			axis x line=center, axis y line*=left, 
			ymin=-1, ymax=1, 
			yticklabels={}, xticklabels={}, 
			xlabel={$k$}, ylabel={$r[kT_s]$},
			every axis x label/.style={
				at={(ticklabel* cs:1.05)},
				anchor=west
				},
			every axis y label/.style={
				at={(ticklabel* cs:0.5)},
				anchor=south,
				rotate=90
				},
			]
		\addplot[ycomb, domain=-0:1,  samples=11, solid,  black, mark=*, mark size=1.5pt] 
		  plot {sin(deg(2*pi*1.33*x))};
		\end{axis}
		
		% Quantized plot.
		\begin{axis}[
			at={(s)},
			anchor=center,
			grid=major, 
			x=14mm, y=7mm, 
			axis x line=center, axis y line*=left, 
			ymin=-1, ymax=1, 
			yticklabels={}, xticklabels={}, 
			xlabel={$t$}, ylabel={$r_q(t)$},
			every axis x label/.style={
				at={(ticklabel* cs:1.05)},
				anchor=west
				},
			every axis y label/.style={
				at={(ticklabel* cs:0.5)},
				anchor=south,
				rotate=90
				},
			]
		\addplot[domain=-0:1, black]
		 coordinates {(0,0) (0.030,0) (0.030,0.5) (0.101,0.5) (0.101,1) (0.274,1) (0.274,0.5) (0.345,0.5) (0.345,0) (0.406,0) (0.406,-0.5) (0.477,-0.5) (0.477,-1) (0.650,-1) (0.650,-0.5) (0.721,-0.5) (0.721,0) (0.782,0) (0.782,0.5) (0.853,0.5) (0.853,1) (1,1)};
		 \end{axis}
		
		% Sampled and quantized plot.
		\begin{axis}[
			at={(e)},
			anchor=center,
			grid=major, 
			x=14mm, y=7mm, 
			axis x line=center, axis y line*=left, 
			ymin=-1, ymax=1, 
			yticklabels={}, xticklabels={}, 
			xlabel={$k$}, ylabel={$r_q[kT_s]$},
			every axis x label/.style={
				at={(ticklabel* cs:1.05)},
				anchor=west
				},
			every axis y label/.style={
				at={(ticklabel* cs:0.5)},
				anchor=south,
				rotate=90
				},
			]
		\addplot[ycomb, domain=-0:1, solid, black, mark=*, mark size=1.5pt]
		 coordinates {(0,0) (0.1,0.5) (0.2,1) (0.3,0.5) (0.4,0) (0.5,-1) (0.6,-1) (0.7,-0.5) (0.8,0.5) (0.9,1) (1,1)};
		\end{axis}
	\end{tikzpicture}
	\caption{A continuous-time, continuous-value signal $r(t)$ is sampled to produce a discrete-time, continuous-value signal $r[kT_s]$. $r(t)$ independently undergoes quantization to yield a continuous-time, discrete-value signal $r_q(t)$. When both processes are applied in sequence, a discrete-time, discrete-value signal $r_q[kT_s]$ is the result.}
	\label{fig:samp-quant}
\end{figure}

Sigma delta modulation is a widely used technique for \gls{A/D} and \gls{D/A} conversion of signals that provides high resolution through the techniques of oversampling and noise shaping. Oversampling trades throughput for resolution, thus the sigma delta modulator generally lies between integrating converters, which are specialized for near-dc signals, and high-speed architectures, such as successive approximation and flash. The sigma delta quantization scheme is especially applicable to signals with low to moderate frequency content. Signals with these properties include most biosignals such as those recorded electrically (\gls{EEG}, \gls{ECG}) or through other means using transducers (\gls{PPG}), as well as audio signals.

\section{Oversampling and Noise Shaping}
\label{sec:in-os-ns}

Oversampling is simply the process where the analog signal is sampled at a rate higher than what the sampling theorem would dictate for perfect reconstruction, expressed as the \gls{OSR} relative to the Nyquist frequency. It may seem that this does not have a direct benefit \emph{per se}, but it allows a less demanding analog \gls{AAF} to be used, saving circuit area. It also permits the quantization error to be spread across a larger bandwidth to increase resolution. Assuming quantization error can be modelled by white noise, oversampling reduces the in-band quantization noise power \gls{pq} by a factor directly proportional to \gls{OSR} \cite{DeLaRosa2011} as seen in \autoref{eq:pq-osr}, where \gls{delta} is the difference between quantization levels. These two advantages --- reducing analog circuit complexity and increasing resolution --- are common goals in sigma delta modulator design.

\begin{equation}
	P_Q = \frac{\Delta^2}{12 \cdot OSR} \label{eq:pq-osr}
\end{equation}

It may appear that oversampling alone quickly becomes impractical because one must approach very high sampling frequencies to increase the \gls{SQNR} substantially. However, this assumes that the quantization noise is evenly distributed across the spectrum. Noise shaping is the use of a filter operating on the oversampled signal to push quantization noise out of the signal band where it can be removed by \gls{DRF}. This behaviour is implemented by wrapping the filter and quantizer in a feedback loop. With the same white noise assumption, the tradeoff between in-band shaped quantization noise and \gls{OSR} is improved for ideal loop filters when order \gls{order} is increased as shown in \autoref{eq:pq-osr-ns} \cite{DeLaRosa2011}. The effect of oversampling and noise shaping is demonstrated in \autoref{fig:os-ns-compare}. 

\begin{equation}
	P_Q = \frac{\Delta^2\pi^{2n}}{12\left(2n + 1\right) \cdot OSR^{2n + 1}} \label{eq:pq-osr-ns}
\end{equation}

\begin{figure}
\noindent\makebox[\textwidth]{
	\centering
	\begin{tikzpicture}[ampersand replacement=\&,scale=0.75, every node/.style={scale=0.75}]
		\node[coordinate] (g1) at (-2,2.5) {};
		% Place nodes using a matrix
		\matrix (m0) at (0,5) [row sep=0mm, column sep=5mm, matrix anchor=north west]
		{
			%------------------------------------------------------------------------------------------------------------------------------------------------
			\node[coordinate]								(m0-00) {};							\&
			\node[coordinate]								(m0-01) {};							\&
			\node[coordinate,label={above:\PulseHigh \ $f_s$}]			(m0-02) {};							\& \\
			%------------------------------------------------------------------------------------------------------------------------------------------------
			\node[coordinate]								(m0-10) {};							\&
			\node[dspsquare,label={above:AAF}]					(m0-11) {};							\&
			\node[dspsquare]								(m0-12) {S/H};						\&
			\node[dspsquare,label={above:Q}]					(m0-13) {\RaisingEdge};					\& \\
			%------------------------------------------------------------------------------------------------------------------------------------------------
		};
		
		\draw[->] (m0-02) -- (m0-12);
		%\draw[dspconn] (m0-10) -- (m0-11);
		\draw[dspconn] (m0-11) -- (m0-12);
		\draw[dspconn] (m0-12) -- (m0-13);
		\pgfplotsset{width=2.25cm,height=2.25cm,xmin=0.1,xmax=1000000,ymin=0.0001,ymax=10}
		\begin{loglogaxis}[
				at={($(m0-11) + (-9,-9)$)},
				ticks=none,
				axis x line*=bottom,
				axis y line*=left
			 ]
			\addplot[domain=1:100000]  {(60*x+10000)/(x*x + 60*x+10000)};
		\end{loglogaxis}
		
		\matrix (m1) at (0,2.5) [row sep=0mm, column sep=5mm, matrix anchor=north west]
		{
			%------------------------------------------------------------------------------------------------------------------------------------------------
			\node[coordinate]								(m1-00) {};							\&
			\node[coordinate]								(m1-01) {};							\&
			\node[coordinate,label={above:\PulseHigh \ $OSR \cdot f_s$}]	(m1-02) {};							\& \\
			%------------------------------------------------------------------------------------------------------------------------------------------------
			\node[dspnodefull]								(m1-10) {};							\&
			\node[dspsquare,label={above:AAF}]					(m1-11) {};							\&
			\node[dspsquare]								(m1-12) {S/H};						\&
			\node[dspsquare,label={above:Q}]					(m1-13) {\RaisingEdge};					\&
			\node[dspsquare,label={above:DRF}]					(m1-14) {};							\&
			\node[dspfilter]								(m1-15) {$\downarrow OSR$};				\& \\
			%------------------------------------------------------------------------------------------------------------------------------------------------
		};
		
		\draw[->] (m1-02) -- (m1-12);
		\draw[dspconn] (m1-10) -- (m1-11);
		\draw[dspconn] (m1-11) -- (m1-12);
		\draw[dspconn] (m1-12) -- (m1-13);
		\draw[dspconn] (m1-13) -- (m1-14);
		\draw[dspconn] (m1-14) -- (m1-15);
		\pgfplotsset{width=2.25cm,height=2.25cm,xmin=0.1,xmax=1000000,ymin=0.0001,ymax=10}
		\begin{loglogaxis}[
				at={($(m1-11) + (-9,-9)$)},
				ticks=none,
				axis x line*=bottom,
				axis y line*=left
			 ]
			\addplot[domain=1:100000]  {(60*x+10000)/(x*x + 60*x+10000)};
		\end{loglogaxis}
		\pgfplotsset{width=2.25cm,height=2.25cm,xmin=0.1,xmax=1000000,ymin=0.0001,ymax=10}
		\begin{loglogaxis}[
				at={($(m1-14) + (-9,-9)$)},
				ticks=none,
				axis x line*=bottom,
				axis y line*=left
			 ]
			\addplot[domain=1:100000]  {(60*x+10000)/(x*x + 60*x+10000)};
		\end{loglogaxis}
		
		\matrix (m2) at (0,0) [row sep=0mm, column sep=5mm, matrix anchor=north west]
		{
			%-----------------------------------------------------------------------------------------------------------------------------------------------
			\node[coordinate]								(m2-00) {};							\&
			\node[coordinate]								(m2-01) {};							\&
			\node[coordinate,label={above:\PulseHigh \ $OSR \cdot f_s$}]	(m2-02) {};							\& \\
			%------------------------------------------------------------------------------------------------------------------------------------------------
			\node[coordinate]								(m2-10) {};							\&
			\node[dspsquare,label={above:AAF}]					(m2-11) {};							\&
			\node[dspsquare]								(m2-12) {S/H};						\&
			\node[dspadder,label={below left:$-$}]				(m2-13) {};							\&
			\node[dspsquare,label={above:LF}]					(m2-14) {$\int$};						\&
			\node[dspsquare,label={above:Q}]					(m2-15) {\RaisingEdge};					\&
			\node[dspnodefull]								(m2-16) {};							\&
			\node[dspsquare,label={above:DRF}]					(m2-17) {};							\&
			\node[dspfilter]								(m2-18) {$\downarrow OSR$};				\&
			\node[dspnodeopen,dsp/label=right]					(m2-19) {$y_3[k]$};					\& \\
			%------------------------------------------------------------------------------------------------------------------------------------------------
			\node[coordinate]								(m2-20) {};							\&
			\node[coordinate]								(m2-21) {};							\&
			\node[coordinate]								(m2-22) {};							\&
			\node[coordinate]								(m2-23) {};							\&
			\node[coordinate]								(m2-24) {};							\&
			\node[coordinate]								(m2-25) {};							\&
			\node[coordinate]								(m2-26) {};							\& \\
			%------------------------------------------------------------------------------------------------------------------------------------------------
		};
		
		\draw[->] (m2-02) -- (m2-12);
		%\draw[dspconn] (m2-10) -- (m2-11);
		\draw[dspconn] (m2-11) -- (m2-12);
		\draw[dspconn] (m2-12) -- (m2-13);
		\draw[dspconn] (m2-13) -- (m2-14);
		\draw[dspconn] (m2-14) -- (m2-15);
		\draw[dspline] (m2-15) -- (m2-16);
		\draw[dspconn] (m2-16) -- (m2-17); 
		\draw[dspconn] (m2-17) -- (m2-18);
		\draw[dspconn] (m2-18) -- (m2-19);
		\draw[dspline] (m2-16) -- (m2-26);
		\draw[dspline] (m2-26) -- (m2-23);
		\draw[dspconn] (m2-23) -- (m2-13);
		\pgfplotsset{width=2.25cm,height=2.25cm,xmin=0.1,xmax=1000000,ymin=0.0001,ymax=10}
		\begin{loglogaxis}[
				at={($(m2-11) + (-9,-9)$)},
				ticks=none,
				axis x line*=bottom,
				axis y line*=left
			 ]
			\addplot[domain=1:100000]  {(60*x+10000)/(x*x + 60*x+10000)};
		\end{loglogaxis}
		\pgfplotsset{width=2.25cm,height=2.25cm,xmin=0.1,xmax=1000000,ymin=0.0001,ymax=10}
		\begin{loglogaxis}[
				at={($(m2-17) + (-9,-9)$)},
				ticks=none,
				axis x line*=bottom,
				axis y line*=left
			 ]
			\addplot[domain=1:100000]  {(60*x+10000)/(x*x + 60*x+10000)};
		\end{loglogaxis}
		
		\coordinate (m0-10x) at (m1-10 |- m0-11); % If (m0-10) is used, there is slight misalignment (not sure why).
		\coordinate (m2-10x) at (m1-10 |- m2-11); % If (m0-10) is used, there is slight misalignment (not sure why).
		\draw[dspconn] (m0-10x) -- (m0-11);
		\draw[dspconn] (m2-10x) -- (m2-11);
		\draw[dspline] (m0-10x) -- (m1-10);
		\draw[dspline] (m1-10) -- (m2-10x);
		\node[dspnodeopen,dsp/label=left] (r) at ($(m1-10) + (-0.5cm, 0)$) {$r(t)$};
		\draw[dspline] (r) -- (m1-10);
		
		\node[coordinate] (g-y2) at ($(m2-19) + (4cm,0)$) {};
		\coordinate (g-y1) at (g-y2 |- m1-15);
		\coordinate (g-y0) at (g-y2 |- m0-13);
		\node[dspnodeopen,dsp/label=right] (y1) at (m2-19 |- m1-15) {$y_2[k]$};
		\node[dspnodeopen,dsp/label=right] (y0) at (m2-19 |- m0-13) {$y_1[k]$};
		
		\draw[dspconn] (m0-13) -- (y0);
		\draw[dspconn] (m1-15) -- (y1);
		
		\begin{axis}[
			at={($(r) + (-3cm,0)$)},
			anchor=center,
			width=6cm, height=3.75cm,
			anchor=center, 
			xmin=0, xmax=4,
			ymin=-100, ymax=300,
			axis x line=bottom, axis y line=left, axis line style={-},
			xticklabels={0,1,2,3,\SI{4}{\second}}, xtick={0,1,2,3,4},
			yticklabels={, 0, \SI{300}{\micro\volt}}, ytick={-100, 0, 300}
			]
			\addplot[solid,black] table [x=t, y=r, col sep=comma] {data/comparison-r.csv};
		\end{axis}
		
		\begin{axis}[
			at={(g-y0)},
			anchor=center,
			width=6cm, height=3.75cm,
			anchor=center, 
			xmin=0, xmax=4,
			ymin=-100, ymax=300,
			axis x line=none, axis y line=left, axis line style={-},
			xticklabels={0,1,2,3,\SI{4}{\second}}, xtick={0,1,2,3,4},
			yticklabels={, 0, \SI{300}{\micro\volt}}, ytick={-100, 0, 300}
			]
			\addplot[solid,black] table [x=t, y=y, col sep=comma] {data/comparison-y0.csv};
		\end{axis}
		
		\begin{axis}[
			at={(g-y1)},
			anchor=center,
			width=6cm, height=3.75cm,
			anchor=center, 
			xmin=0, xmax=4,
			ymin=-100, ymax=300,
			axis x line=none, axis y line=left, axis line style={-},
			xticklabels={0,1,2,3,\SI{4}{\second}}, xtick={0,1,2,3,4},
			yticklabels={, 0, \SI{300}{\micro\volt}}, ytick={-100, 0, 300}
			]
			\addplot[solid,black] table [x=t, y=y, col sep=comma] {data/comparison-y1.csv};
		\end{axis}
		
		\begin{axis}[
			at={(g-y2)},
			anchor=center,
			width=6cm, height=3.75cm,
			anchor=center, 
			xmin=0, xmax=4,
			ymin=-100, ymax=300,
			axis x line=bottom, axis y line=left, axis line style={-},
			xticklabels={0,1,2,3,\SI{4}{\second}}, xtick={0,1,2,3,4},
			yticklabels={, 0, \SI{300}{\micro\volt}}, ytick={-100, 0, 300}
			]
			\addplot[solid,black] table [x=t, y=y, col sep=comma] {data/comparison-y2.csv};
		\end{axis}
		
	\end{tikzpicture}}
	\caption{A comparison between na\"{i}ve quantization (top), 10 times oversampled quantization (middle), and first order sigma delta modulation (bottom). The graphs on the right show the increasing quality of an \glsentryshort{EEG} signal \cite{Blankertz2007} sampled to a final rate of \SI{100}{\hertz} and quantized by Q with 5 bits by each scheme.}
	\label{fig:os-ns-compare}
\end{figure}

\section{Basic Structure}
\label{sec:in-bs}

We introduce the basic block diagram of a sigma delta modulator and nomenclature that will be used herein. For brevity, we limit the scope to sigma delta \gls{A/D} converters but the concepts are easily transferrable to the \gls{D/A} case. Modulators can be one of two main classes, \gls{CT} or \gls{DT} referring to the nature of the \gls{LF}. 

\subsection{Discrete-Time Modulator}
\label{sec:in-dtm}

\begin{figure}[h]
\noindent\makebox[\textwidth]{
	\centering
	% DT Sigma Delta Modulator
	\begin{tikzpicture}[ampersand replacement=\&,scale=0.75, every node/.style={scale=0.75}]
	
		% Place nodes using a matrix
		\matrix (m1) [row sep=2.5mm, column sep=5mm]
		{
			%------------------------------------------------------------------------------------------------------------------------
			\node[coordinate]								(m0-00) {};				\&
			\node[coordinate]								(m0-01) {};				\&
			\node[coordinate,label={above:\PulseHigh \ $OSR \cdot f_s$}]	(m0-02) {};				\& \\
			%------------------------------------------------------------------------------------------------------------------------
			\node[dspnodeopen,dsp/label=left]					(m1-00) {$r_0(t)$};			\&
			\node[dspsquare,label={above:AAF}]					(m1-01) {};				\&
			\node[dspsquare]								(m1-02) {S/H};			\&
			\node[coordinate,label={above:$r[k]$}]				(m1-03) {};				\&
			\node[dspfilter]								(m1-04) {$H_0(z)$};		\&
			\node[coordinate]								(m1-05) {};				\&
			\node[coordinate]								(m1-06) {};				\&
			\node[coordinate]								(m1-07) {};				\& \\
			%------------------------------------------------------------------------------------------------------------------------
			\node[coordinate]								(m2-00) {};				\&
			\node[coordinate]								(m2-01) {};				\&
			\node[coordinate]								(m2-02) {};				\&
			\node[coordinate]								(m2-03) {};				\&
			\node[dspadder,label={below left:$-$}]				(m2-04) {};				\&
			\node[dspfilter]								(m2-05) {$H_1(z)$};		\&
			\node[coordinate,label={$u[k]$}]					(m2-06) {};				\&
			\node[dspsquare,label={below:Quantizer}]				(m2-07) {\RaisingEdge};		\&
			\node[dspnodefull]								(m2-08) {};				\&
			\node[coordinate,label={above:$y[k]$}]				(m2-09) {};				\&
			\node[dspsquare,label={above:DRF}]					(m2-10) {};				\& 
			\node[dspfilter]								(m2-11) {$\downarrow OSR$};	\&
			\node[dspnodeopen,dsp/label=right]					(m2-12) {$y[m]$};			\& \\
			%------------------------------------------------------------------------------------------------------------------------
			\node[coordinate]								(m3-00) {};				\&
			\node[coordinate]								(m3-01) {};				\&
			\node[coordinate]								(m3-02) {};				\&
			\node[coordinate]								(m3-03) {};				\&
			\node[coordinate]								(m3-04) {};				\& 
			\node[coordinate]								(m3-05) {};				\& 
			\node[coordinate]								(m3-06) {};				\& 
			\node[coordinate]								(m3-07) {};				\& 
			\node[coordinate]								(m3-08) {};				\& 
			\node[coordinate]								(m3-09) {};				\& \\
			%------------------------------------------------------------------------------------------------------------------------
		};
	
		%\node[draw,inner xsep=15pt,inner ysep=10pt,dashed,fit={($(m1-07.north)+(-0.5, 0.7)$) ($(m2-07.south)+(0.5, -0.6)$)},label={[align=center]above:Linear Model}] {};
		\node[draw,inner xsep=15pt,inner ysep=10pt,dashed,fit={($(m1-04.north west)+(-0.5, 0.3)$) ($(m2-05.south east)+(0.4, -0.5)$)},label=above:{Loop Filter $H(z)$}] {};

		\draw[->]		(m0-02) -- (m1-02);
		\draw[dspconn]	(m1-00) -- (m1-01);
		\draw[dspconn]	(m1-01) to node[midway,above] {$r(t)$} (m1-02);
		\draw[dspconn] 	(m1-02) -- (m1-04);
		\draw[dspconn] 	(m1-04) -- (m2-04);
		\draw[dspline] 	(m2-05) -- (m2-07);
		\draw[dspconn] 	($(m2-06.east)+(6pt, 0)$) -- (m2-07);
		\draw[dspline]	(m2-07) -- (m2-08);
		\draw[dspconn] 	(m2-08) -- (m2-10);
		\draw[dspline] 	(m2-08) -- (m3-08);
		\draw[dspline] 	(m3-08) -- (m3-03);
		\draw[dspline]	(m3-03) -- (m2-03);
		\draw[dspconn] 	(m2-03) -- (m2-04);
		\draw[dspconn] 	(m2-04) to node[midway,above] {$e[k]$} (m2-05);
		%\draw[dspconn] 	(m1-07) -- (m2-07);
		\draw[dspconn]	(m2-10) -- (m2-11);
		\draw[dspconn]	(m2-11) -- (m2-12);
		\draw[OliveGreen, ->, out=30, in=105, looseness=0.85] ($(m1-03)+(0, 0.8)$) to node[below, xshift=-22pt] {$T(z)$} ($(m2-09)+(0.1, 0.8)$);
		\draw[RedOrange, ->, out=-45, in=135, looseness=1] ($(m1-03)+(0, -0.2)$) to node[below, xshift=-5pt] {$S(z)$} ($(m2-04)+(0.8, 0.75)$);
		
		\pgfplotsset{width=2.25cm,height=2.25cm,xmin=0.1,xmax=1000000,ymin=0.0001,ymax=10}
		\begin{loglogaxis}[
				at={($(m1-01) + (-9,-9)$)},
				ticks=none,
				axis x line*=bottom,
				axis y line*=left
			 ]
			\addplot[domain=1:100000]  {(60*x+10000)/(x*x + 60*x+10000)};
		\end{loglogaxis}
		\pgfplotsset{width=2.25cm,height=2.25cm,xmin=0.1,xmax=1000000,ymin=0.0001,ymax=10}
		\begin{loglogaxis}[
				at={($(m2-10) + (-9,-9)$)},
				ticks=none,
				axis x line*=bottom,
				axis y line*=left
			 ]
			\addplot[domain=1:100000]  {(60*x+10000)/(x*x + 60*x+10000)};
		\end{loglogaxis}
	\end{tikzpicture}}
	\caption{The basic block diagram of a \glsentryshort{DT} sigma delta \glsentryshort{A/D} converter.} \label{fig:basic-struct-dt}
\end{figure}

For the \gls{DT} class of modulators, we reference \autoref{fig:basic-struct-dt}. The analog front-end includes the \gls{AAF} and sample-and-hold block. This subsystem conditions the input signal $r_0(t)$ and samples it outside the loop to produce \gls{DT} signal $r[k]$. In the modulator loop, the 2-input 1-output \gls{LF} operates on $r[k]$ and the feedback signal, producing intermediate signal $u[k]$ with shaped noise. Then, $u[k]$ undergoes quantization producing discrete-value output $y[k]$. The quantizer output is fed back to the \gls{LF} and also passed along. The final subsystem filters the signal from the shaped noise in the digital domain with a downsampling \gls{DRF} to yield the final digital output $y[m]$. 

From a control systems perspective, there are a couple of transfer functions that will be used to analyze and synthesize loop filters. The sensitivity function \gls{S}, where \gls{sorz}$=z$, is known as the \gls{NTF} of the modulator because it shows how the quantization error is filtered in the linearized model. The complementary sensitivity function \gls{T} is known as the \gls{STF} of the modulator and shows how the signal is transformed by the modulator loop.

\subsection{Continuous-Time Modulator}
\label{sec:in-ctm}


\begin{figure}[h]
\noindent\makebox[\textwidth]{
	\centering
	% CT Sigma Delta Modulator
	\begin{tikzpicture}[ampersand replacement=\&,scale=0.75, every node/.style={scale=0.75}]
	
		% Place nodes using a matrix
		\matrix (m1) [row sep=2.5mm, column sep=5mm]
		{
			%------------------------------------------------------------------------------------------------------------------------
			\node[dspnodeopen,label={left:$r(t)$}]				(m1-02) {};				\&
			\node[coordinate]								(m1-03) {};				\&
			\node[dspfilter]								(m1-04) {$H_0(s)$};		\&
			\node[coordinate]								(m1-05) {};				\&
			\node[coordinate,label={above:\PulseHigh \ $OSR \cdot f_s$}]	(m1-06) {};				\&
			\node[coordinate]								(m1-07) {};				\& \\
			%------------------------------------------------------------------------------------------------------------------------
			\node[coordinate]								(m2-02) {};				\&
			\node[coordinate]								(m2-03) {};				\&
			\node[dspadder,label={below left:$-$}]				(m2-04) {};				\&
			\node[dspfilter]								(m2-05) {$H_1(s)$};		\&
			\node[dspsquare]								(m2-06) {S/H};			\&
			\node[dspsquare,label={below:Quantizer}]				(m2-07) {\RaisingEdge};		\&
			\node[dspnodefull]								(m2-08) {};				\&
			\node[coordinate,label={above:$y[k]$}]				(m2-09) {};				\&
			\node[dspsquare,label={above:DRF}]					(m2-10) {};				\& 
			\node[dspfilter]								(m2-11) {$\downarrow OSR$};	\&
			\node[dspnodeopen,dsp/label=right]					(m2-12) {$y[m]$};			\& \\
			%------------------------------------------------------------------------------------------------------------------------
			\node[coordinate]								(m3-02) {};				\&
			\node[coordinate]								(m3-03) {};				\&
			\node[coordinate]								(m3-04) {};				\& 
			\node[coordinate]								(m3-05) {};				\& 
			\node[dspadc]								(m3-06) {$P(s)$};			\& 
			\node[coordinate]								(m3-07) {};				\& 
			\node[coordinate]								(m3-08) {};				\& 
			\node[coordinate]								(m3-09) {};				\& \\
			%------------------------------------------------------------------------------------------------------------------------
		};
	
		%\node[draw,inner xsep=15pt,inner ysep=10pt,dashed,fit={($(m1-07.north)+(-0.5, 0.7)$) ($(m2-07.south)+(0.5, -0.6)$)},label={[align=center]above:Linear Model}] {};
		\node[draw,inner xsep=15pt,inner ysep=10pt,dashed,fit={($(m1-04.north west)+(-0.5, 0.3)$) ($(m2-05.south east)+(0.4, -0.5)$)},label=above:{Loop Filter $H(s)$}] {};

		\draw[dspconn] 	(m1-02) -- (m1-04);
		\draw[dspconn] 	(m1-04) -- (m2-04);
		\draw[->]		(m1-06) -- (m2-06);
		\draw[dspconn] 	(m2-05) to node[midway,above,xshift=5pt] {$u(t)$} (m2-06);
		\draw[dspconn]	(m2-06) to node[midway,above,xshift=-7pt] {$u[k]$} (m2-07);
		\draw[dspconn] 	($(m2-06.east)+(6pt, 0)$) -- (m2-07);
		\draw[dspline]	(m2-07) -- (m2-08);
		\draw[dspconn] 	(m2-08) -- (m2-10);
		\draw[dspline] 	(m2-08) -- (m3-08);
		\draw[dspconn] 	(m3-08) -- (m3-06);
		\draw[dspline]	(m3-06) -- (m3-03);
		\draw[dspline]	(m3-03) -- (m2-03);
		\draw[dspconn] 	(m2-03) -- (m2-04);
		\draw[dspconn] 	(m2-04) to node[midway,above] {$e(t)$} (m2-05);
		%\draw[dspconn] 	(m1-07) -- (m2-07);
		\draw[dspconn]	(m2-10) -- (m2-11);
		\draw[dspconn]	(m2-11) -- (m2-12);
		\draw[OliveGreen, ->, out=30, in=105, looseness=0.85] ($(m1-02)+(-0.4, 0.4)$) to node[below, xshift=-22pt] {$T(s)$} ($(m2-09)+(0.1, 0.8)$);
		%\draw[RedOrange, ->, out=-45, in=135, looseness=1] ($(m1-07)+(0.35, 0.25)$) to node[above, xshift=5pt] {$S(s)$} ($(m2-09)+(0, 0.75)$);
		\draw[RedOrange, ->, out=-45, in=135, looseness=1] ($(m1-02)+(-0.4, -0.3)$) to node[below, xshift=5pt] {$S(z)$} ($(m2-04)+(0.7, 0.7)$);
		
		\pgfplotsset{width=2.25cm,height=2.25cm,xmin=0.1,xmax=1000000,ymin=0.0001,ymax=10}
		\begin{loglogaxis}[
				at={($(m2-10) + (-9,-9)$)},
				ticks=none,
				axis x line*=bottom,
				axis y line*=left
			 ]
			\addplot[domain=1:100000]  {(60*x+10000)/(x*x + 60*x+10000)};
		\end{loglogaxis}
	\end{tikzpicture}}
	\caption{The basic block diagram of a \glsentryshort{CT} sigma delta \glsentryshort{A/D} converter.} \label{fig:basic-struct-ct}
\end{figure}

For the \gls{CT} class of modulators, we reference \autoref{fig:basic-struct-ct}. The structure is similar except the \gls{LF} operates directly on analog input $r(t)$ in the \gls{CT} domain and sampling is done inside the loop. The \gls{AAF} is no longer necessary in most cases as the \gls{LF} precedes the sampling block and implicitly attenuates components of the signal that would result in aliasing. Finally, signal $y[k]$ must undergo \gls{D/A} conversion during feedback, modelled witht the pulse transfer function $P(s)$. 

The \gls{NTF} and \gls{STF} of a \gls{CT} sigma delta modulator are more difficult to define because they are transfer functions involving both \gls{CT} and \gls{DT} signals. The \gls{DT} equivalence principle states that there is a \gls{DT} modulator model that exactly describes the \gls{CT} design at the sampling instants, because the modulator is overall a sampled data system \cite[Sec. 3.2]{Ortmanns2005}. Thus, \gls{DT} transfer functions can be derived for this purpose. However, these equivalent transfer functions may be difficult to manipulate due to their dependence on $P(s)$. For the purposes of this thesis, we omit the sampling block during design and use the simplification that \gls{S} and \gls{T} are \gls{CT} (\gls{sorz}$=s$) transfer functions mapping $t(t) \rightarrow e(t)$ and $r(t) \rightarrow y(t)$, respectively.

\section{Loop Filter}
\label{sec:in-lf}

Together, quantization and noise shaping permit a coarser quantizer element to be used. A common design pattern is to use a high ($>2$) order \gls{LF} paired with a 1-bit quantizer, which is advantageous from a circuit design perspective because a quantizer with just two levels is inherently linear. In addition, low order sigma delta loops often suffer from spurious tones \cite[Sec. 2.6.1]{Schreier1997}. Unfortunately, as \gls{LF} order is increased, the tendency of the loop to become unstable does as well. While first and second order designs are provably stable for DC inputs \cite{Hein1993}, high order filters require careful design to avoid instability. Ensuring stability while maintaining performance is a difficult task due to the presence of the highly nonlinear quantizer. Note that the nonlinearity makes analysis complicated, a stable linear model does not imply a stable modulator while an unstable model can even result in a stable modulator \cite{Risbo1994}.

The design of the noise shaping loop filter is the focus of this thesis. Modelling the loop filter as a 2-input 1-output system as shown in \autoref{sec:in-bs} allows the \gls{NTF} to be determined by $H_1(\lambda)$ alone while the \gls{STF} can be modified independently with filter $H_0(\lambda)$, without loss of generality:

\begin{align}
	S(\lambda) = \frac{1}{1 - H_1(\lambda)} \\
	T(\lambda) = \frac{H_0(\lambda)}{1 - H_1(\lambda)}. \label{eq:t}
\end{align}

We desire an \gls{NTF} that results in a stable linear model, rejects noise in the signal band as much as possible, and has low gain in the out-of-band region to promote stability. The \gls{STF} is less important as $H_0(\lambda)$ can be interpreted as a pre-filter to modify the \gls{STF}, but we prefer unity gain in the signal band.

For a first order modulator, a pure integrator can be used as the loop filter $H_0(\lambda)$. For higher orders, it is common to choose a prototype \gls{NTF} from a family of filters. For example, the popular Delta Sigma Toolbox for MATLAB \cite[Appx. B]{Schreier1997} uses a Chebyshev type II filter for this purpose. The choice of filter greatly affects the stability of the loop, so the traditional design procedure involves extensive simulation under varying input conditions to ensure instability is unlikely during normal operation. Once unstable, the filter states must be reset in order to restore operation. Various schemes to detect the onset of instability \cite{Wong2004} and avoid it with gain scaling \cite{Sooch1989}, internal linear feedback \cite{Moussavi1994}, and automatic resetting schemes \cite{Eynde1991}.

\section{Related Works}
\label{sec:in-rw}

Optimization techniques have been used to design \gls{NTF}s with more degrees of freedom than those made with a single filter prototype. A simple example is that from \cite[Sec. 4.3]{Schreier1997}, where the zeros of the prototype \gls{NTF} are optimized by approximating the integral of the \gls{NTF} in the pass-band, then minimizing it analytically by equating its derivative to zero. The procedure results in an optimal spreading of zeros across the signal bandwidth for the given \gls{NTF} poles. One of the first optimization-based approaches to \gls{NTF} design was the \gls{CLANS} methodology that minimizes \gls{pq} under the white quantization noise assumption \cite{Kenney1988}. This is done using nonlinear optimization to find stable \gls{NTF} pole locations that minimize the accumulation of quantization error subject to some stability and realizability constraints.

Using the principles from $\mathcal{H}_\infty$ control and its associated \gls{LMI} methods, one can define the quantizer as a very simple feedthrough plant and introduce weighting filters on the feedback error signal \gls{e}, loop filter output \gls{u}, and quantizer output \gls{y} to design the loop filter as a controller for various performance and stability constraints \cite{Oberoi2004}. However, the system is bound to the order of the plant augmented with weighting filters and relies on the designer to choose the weights. Choosing weighting filters that are ideal is almost as difficult a task as just choosing the prototype \gls{NTF} directly. Despite this, if a known \gls{AAF} or \gls{DRF} is specified in advance, it may be used as a sort of weighting filter and an optimal \gls{LF} can be designed around it \cite{Ohno2017b}. Applications for this method could be optimizing the \gls{STF} to a psychoacoustic model or making use of existing filters in the signal path.

More recently, the \gls{GKYP} lemma has been applied to sigma delta modulator design. The lemma provides a link between a finite frequency domain inequality, such as specifications on the \gls{NTF} gain, and a linear matrix inequality condition, which can be solved using efficient interior point methods. Using this lemma, the techniques of $\mathcal{H}_\infty$ control can be applied to a transfer function but restricted to a frequency band. This eliminates the need for weighting filters that specify a select band of interest. Unfortunately, the problem becomes non-convex and hard to solve if both poles and zeros are to be optimized simultaneously as is the case with an \gls{IIR} filter. As a workaround, the \gls{NTF} poles may be fixed to a prototype design and just the zeros optimized \cite{Osqui2007}, similar to what was described above. Alternatively, a \gls{FIR} \gls{NTF} form may be assumed \cite{Nagahara2012, Tariq2016} then possibly converted to \gls{IIR} form using approximate methods such as least-squares or Yule-Walker \cite{Tariq2017}. Aside from the large delay introduced, the \gls{FIR} form is not the optimal choice according to \cite{Derpich2008}. Iterative methods have shown promise in providing a workaround to the non-convexity associated with direct \gls{IIR} design. A survey of some of these methods is presented in \cite{Callegari2015}.

\section{Organization of this Thesis}
\label{sec:in-org}

Having established some background on the workings and nomenclature of a sigma delta modulator, we expand upon this in \autoref{ch:Modelling} to show modifications to the general sigma delta model based on control theory that will permit it to be used in an optimization framework. In \autoref{ch:Stability}, we introduce various stability criteria ranging from heuristics to sufficient conditions and their impact on performance. Following the discussion of the role of optimization in loop filter design, \autoref{ch:Optimization} bridges the model and stability criteria chapters by introducing a semidefinite programming framework that supports the aforementioned criteria. The design process is discussed in \autoref{ch:Examples}, with emphasis on simulation results as well as an empirical study of the tradeoff between performance and stability when designing to different criteria. Finally, we conclude in \autoref{ch:Conclusions} with some discussion about the merits and shortcomings of this method of sigma delta modulator design and possible directions for future work.

\endinput

Any text after an \endinput is ignored.
You could put scraps here or things in progress.
