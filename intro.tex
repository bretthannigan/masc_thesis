%% The following is a directive for TeXShop to indicate the main file
%%!TEX root = diss.tex

\chapter{Introduction}
\label{ch:Introduction}

The conversion of signals between analog and digital domains is an often encountered problem in signal processing. For an analog signal to be represented digitally, it must undergo the processes of sampling and quantization (\autoref{fig:samp-quant}). The former is the conversion from \gls{CT} to \gls{DT} and can be done without loss of information by the Nyquist-Shannon sampling theorem, given a sufficiently high sample rate. The latter is the mapping from an infinite set of possible values to a fixed number of quantization levels that is required for digital representation with finite memory. Unlike sampling, the process of quantization is non-injective and thus irreversible. The design of signal conversion circuits that minimize the error introduced by quantization is a major problem in mixed signal electronics.

\begin{figure}
	\centering
	\begin{tikzpicture}[ampersand replacement=\&,scale=1, every node/.style={scale=1}]
	
		\node[coordinate] (w) at (0,0) {};
		\node[coordinate] (n) at (5,1.5) {};
		\node[coordinate] (s) at (5,-1.5) {};
		\node[coordinate] (e) at (8.5,0) {};
		\node[dspsquare] (sh2) at (4,0) {S/H};
		\node[dspsquare] (q2) at (6,0) {\RaisingEdge};
		\node[coordinate] (w-up) at ($(w) + (1,0.5)$) {};
		\node[coordinate] (w-right) at ($(w) + (1.25,0)$) {};
		\node[coordinate] (w-low) at ($(w) + (1,-0.5)$) {};
		\node[coordinate] (n-left) at ($(n) + (-1.5,0)$) {};
		\node[coordinate] (s-left) at  ($(s) + (-1.5,0)$) {};
		\node[coordinate] (n-right) at ($(n) + (1.25,0)$) {};
		\node[coordinate] (s-right) at ($(s) + (1.25,0)$) {};
		\node[coordinate] (mid) at ($(e) + (-1.5,0)$) {};
		\node[coordinate] (e-left) at ($(e) + (-1.5,0)$) {};
		
		\path (w-up) -- (n-left) node[dspsquare,midway,sloped] (sh1) {S/H};
		\path (w-up) -- (n-left) node[midway,sloped,yshift=20] {Sampling};
		\path (w-low) -- (s-left) node[dspsquare,midway,sloped] (q1) {\RaisingEdge};
		\path (w-low) -- (s-left) node[midway,sloped,yshift=-20] {Quantization};
		
		\draw[conndspconn] (w-up) -- (sh1);
		\draw[dspconn] (w-low) -- (q1);
		\draw[conndspconn] (sh1) -- (n-left);
		\draw[dspconn] (q1) -- (s-left);		
		\draw[conndspconn] (w-right) -- (sh2);
		\draw[conndspconn] (sh2) -- (q2);
		\draw[dspconn] (q2) -- (mid);
		
		% Analog signal.
		\begin{axis}[
			at={(w)},
			anchor=center,
			grid=major, 
			x=14mm, y=7mm, 
			axis x line=center, axis y line*=left, 
			ymin=-1, ymax=1, 
			yticklabels={}, xticklabels={},
			xlabel={$t$}, ylabel={$r(t)$},
			every axis x label/.style={
				at={(ticklabel* cs:1.05)},
				anchor=west
				},
			every axis y label/.style={
				at={(ticklabel* cs:0.5)},
				anchor=south,
				rotate=90
				},
			]
		\addplot[domain=-0:1,  smooth,  black]
		  plot {sin(deg(2*pi*1.33*x))};
		\end{axis}
		
		% Sampled plot.
		\begin{axis}[
			at={(n)},
			anchor=center,
			grid=major, 
			x=14mm, y=7mm, 
			axis x line=center, axis y line*=left, 
			ymin=-1, ymax=1, 
			yticklabels={}, xticklabels={}, 
			xlabel={$k$}, ylabel={$r[kT_s]$},
			every axis x label/.style={
				at={(ticklabel* cs:1.05)},
				anchor=west
				},
			every axis y label/.style={
				at={(ticklabel* cs:0.5)},
				anchor=south,
				rotate=90
				},
			]
		\addplot[ycomb, domain=-0:1,  samples=11, solid,  black, mark=*, mark size=1.5pt] 
		  plot {sin(deg(2*pi*1.33*x))};
		\end{axis}
		
		% Quantized plot.
		\begin{axis}[
			at={(s)},
			anchor=center,
			grid=major, 
			x=14mm, y=7mm, 
			axis x line=center, axis y line*=left, 
			ymin=-1, ymax=1, 
			yticklabels={}, xticklabels={}, 
			xlabel={$t$}, ylabel={$r_q(t)$},
			every axis x label/.style={
				at={(ticklabel* cs:1.05)},
				anchor=west
				},
			every axis y label/.style={
				at={(ticklabel* cs:0.5)},
				anchor=south,
				rotate=90
				},
			]
		\addplot[domain=-0:1, black]
		 coordinates {(0,0) (0.030,0) (0.030,0.5) (0.101,0.5) (0.101,1) (0.274,1) (0.274,0.5) (0.345,0.5) (0.345,0) (0.406,0) (0.406,-0.5) (0.477,-0.5) (0.477,-1) (0.650,-1) (0.650,-0.5) (0.721,-0.5) (0.721,0) (0.782,0) (0.782,0.5) (0.853,0.5) (0.853,1) (1,1)};
		 \end{axis}
		
		% Sampled and quantized plot.
		\begin{axis}[
			at={(e)},
			anchor=center,
			grid=major, 
			x=14mm, y=7mm, 
			axis x line=center, axis y line*=left, 
			ymin=-1, ymax=1, 
			yticklabels={}, xticklabels={}, 
			xlabel={$k$}, ylabel={$r_q[kT_s]$},
			every axis x label/.style={
				at={(ticklabel* cs:1.05)},
				anchor=west
				},
			every axis y label/.style={
				at={(ticklabel* cs:0.5)},
				anchor=south,
				rotate=90
				},
			]
		\addplot[ycomb, domain=-0:1, solid, black, mark=*, mark size=1.5pt]
		 coordinates {(0,0) (0.1,0.5) (0.2,1) (0.3,0.5) (0.4,0) (0.5,-1) (0.6,-1) (0.7,-0.5) (0.8,0.5) (0.9,1) (1,1)};
		\end{axis}
	\end{tikzpicture}
	\caption{A continuous-time, continuous-value signal $r(t)$ is sampled to produce a discrete-time, continuous-value signal $r[kT_s]$. $r(t)$ independently undergoes quantization to yield a continuous-time, discrete-value signal $r_q(t)$. When both processes are applied in sequence, a discrete-time, discrete-value signal $r_q[kT_s]$ is the result.}
	\label{fig:samp-quant}
\end{figure}

Sigma delta modulation is a widely used method for \gls{A/D} and \gls{D/A} conversion of signals that provides high resolution through the techniques of oversampling and noise shaping. Oversampling trades throughput for resolution. Because of this, the sigma delta modulator generally lies between integrating converters, which are specialized for near-\glsentryshort{DC} signals, and high-speed architectures, such as successive approximation and flash. The sigma delta quantization scheme is especially applicable to signals with low to moderate frequency content. Signals with these properties include most bio-signals such as those recorded electrically (e.g., \gls{EEG}, \gls{ECG}) or through other means using transducers (e.g., \gls{PPG}), as well as audio signals.

\section{Oversampling and Noise Shaping}
\label{sec:in-os-ns}

Oversampling is simply the process where the analog signal is sampled at a rate higher than what the sampling theorem would dictate for perfect reconstruction, expressed as an \gls{OSR} relative to the Nyquist frequency. It may seem that this does not have a direct benefit \emph{per se}, but it allows a less demanding analog \gls{AAF} to be used, saving circuit area. It also permits the quantization error to be spread across a larger bandwidth to increase resolution. Assuming quantization error can be modelled by white noise, oversampling reduces the in-band quantization noise power \gls{pq} by a factor inversely proportional to \gls{OSR} \cite{DeLaRosa2011} as seen in \autoref{eq:pq-osr}, where \gls{delta} is the difference between quantization levels. These two advantages --- reducing analog circuit complexity and increasing resolution --- are common goals in sigma delta modulator design as the sigma delta architecture is known to perform well under non-ideal conditions \cite{Daubechies2010}.

\begin{equation}
	P_Q = \frac{\Delta^2}{12 \cdot OSR} \label{eq:pq-osr}
\end{equation}

It may appear that oversampling alone quickly becomes impractical because one must approach very high sampling frequencies to increase the \gls{SQNR} substantially. However, this assumes that the quantization noise is evenly distributed across the spectrum. Noise shaping is the use of a filter operating on the oversampled signal to push quantization noise out of the signal band where it can be removed by the \gls{DRF}. This behaviour is implemented by wrapping the filter and quantizer in a feedback loop. With the same white noise assumption, the trade-off between in-band shaped quantization noise and \gls{OSR} is improved. For ideal loop filters, as filter order \gls{order} is increased, the in-band noise is reduced by $6n \textrm{ dB/decade}$ as shown in \autoref{eq:pq-osr-ns} \cite{DeLaRosa2011}. The effect of oversampling and noise shaping is demonstrated in \autoref{fig:os-ns-compare}. 

\begin{equation}
	P_Q = \frac{\Delta^2\pi^{2n}}{12\left(2n + 1\right) \cdot OSR^{2n + 1}} \label{eq:pq-osr-ns}
\end{equation}

\begin{landscape}
\begin{figure}
%\makebox[\textwidth]{
	\begin{center}
	\begin{tikzpicture}[ampersand replacement=\&,scale=0.7, every node/.style={scale=0.7}]
		\node[coordinate] (g1) at (-2,2.5) {};
		% Place nodes using a matrix
		\matrix (m0) at (0,5) [row sep=0mm, column sep=5mm, matrix anchor=north west]
		{
			%------------------------------------------------------------------------------------------------------------------------------------------------
			\node[coordinate]								(m0-00) {};							\&
			\node[coordinate]								(m0-01) {};							\&
			\node[coordinate,label={above:\PulseHigh \ $f_s$}]			(m0-02) {};							\& \\
			%------------------------------------------------------------------------------------------------------------------------------------------------
			\node[coordinate]								(m0-10) {};							\&
			\node[dspsquare,label={above:AAF}]					(m0-11) {};							\&
			\node[dspsquare]								(m0-12) {S/H};						\&
			\node[dspsquare,label={above:Q}]					(m0-13) {\RaisingEdge};					\& \\
			%------------------------------------------------------------------------------------------------------------------------------------------------
		};
		
		\draw[->] (m0-02) -- (m0-12);
		%\draw[dspconn] (m0-10) -- (m0-11);
		\draw[dspconn] (m0-11) -- (m0-12);
		\draw[dspconn] (m0-12) -- (m0-13);
		\pgfplotsset{width=2.25cm,height=2.25cm,xmin=0.1,xmax=1000000,ymin=0.0001,ymax=10}
		\begin{loglogaxis}[
				at={($(m0-11) + (-9,-9)$)},
				ticks=none,
				axis x line*=bottom,
				axis y line*=left
			 ]
			\addplot[domain=1:100000]  {(60*x+10000)/(x*x + 60*x+10000)};
		\end{loglogaxis}
		
		\matrix (m1) at (0,2.5) [row sep=0mm, column sep=5mm, matrix anchor=north west]
		{
			%------------------------------------------------------------------------------------------------------------------------------------------------
			\node[coordinate]								(m1-00) {};							\&
			\node[coordinate]								(m1-01) {};							\&
			\node[coordinate,label={above:\PulseHigh \ $OSR \cdot f_s$}]	(m1-02) {};							\& \\
			%------------------------------------------------------------------------------------------------------------------------------------------------
			\node[dspnodefull]								(m1-10) {};							\&
			\node[dspsquare,label={above:AAF}]					(m1-11) {};							\&
			\node[dspsquare]								(m1-12) {S/H};						\&
			\node[dspsquare,label={above:Q}]					(m1-13) {\RaisingEdge};					\&
			\node[dspsquare,label={above:DRF}]					(m1-14) {};							\&
			\node[dspfilter]								(m1-15) {$\downarrow OSR$};				\& \\
			%------------------------------------------------------------------------------------------------------------------------------------------------
		};
		
		\draw[->] (m1-02) -- (m1-12);
		\draw[dspconn] (m1-10) -- (m1-11);
		\draw[dspconn] (m1-11) -- (m1-12);
		\draw[dspconn] (m1-12) -- (m1-13);
		\draw[dspconn] (m1-13) -- (m1-14);
		\draw[dspconn] (m1-14) -- (m1-15);
		\pgfplotsset{width=2.25cm,height=2.25cm,xmin=0.1,xmax=1000000,ymin=0.0001,ymax=10}
		\begin{loglogaxis}[
				at={($(m1-11) + (-9,-9)$)},
				ticks=none,
				axis x line*=bottom,
				axis y line*=left
			 ]
			\addplot[domain=1:100000]  {(60*x+10000)/(x*x + 60*x+10000)};
		\end{loglogaxis}
		\pgfplotsset{width=2.25cm,height=2.25cm,xmin=0.1,xmax=1000000,ymin=0.0001,ymax=10}
		\begin{loglogaxis}[
				at={($(m1-14) + (-9,-9)$)},
				ticks=none,
				axis x line*=bottom,
				axis y line*=left
			 ]
			\addplot[domain=1:100000]  {(60*x+10000)/(x*x + 60*x+10000)};
		\end{loglogaxis}
		
		\matrix (m2) at (0,0) [row sep=0mm, column sep=5mm, matrix anchor=north west]
		{
			%-----------------------------------------------------------------------------------------------------------------------------------------------
			\node[coordinate]								(m2-00) {};							\&
			\node[coordinate]								(m2-01) {};							\&
			\node[coordinate,label={above:\PulseHigh \ $OSR \cdot f_s$}]	(m2-02) {};							\& \\
			%------------------------------------------------------------------------------------------------------------------------------------------------
			\node[coordinate]								(m2-10) {};							\&
			\node[dspsquare,label={above:AAF}]					(m2-11) {};							\&
			\node[dspsquare]								(m2-12) {S/H};						\&
			\node[dspadder,label={below left:$-$}]				(m2-13) {};							\&
			\node[dspsquare,label={above:LF}]					(m2-14) {$\int$};						\&
			\node[dspsquare,label={above:Q}]					(m2-15) {\RaisingEdge};					\&
			\node[dspnodefull]								(m2-16) {};							\&
			\node[dspsquare,label={above:DRF}]					(m2-17) {};							\&
			\node[dspfilter]								(m2-18) {$\downarrow OSR$};				\&
			\node[dspnodeopen,dsp/label=right]					(m2-19) {$y_3[k]$};					\& \\
			%------------------------------------------------------------------------------------------------------------------------------------------------
			\node[coordinate]								(m2-20) {};							\&
			\node[coordinate]								(m2-21) {};							\&
			\node[coordinate]								(m2-22) {};							\&
			\node[coordinate]								(m2-23) {};							\&
			\node[coordinate]								(m2-24) {};							\&
			\node[coordinate]								(m2-25) {};							\&
			\node[coordinate]								(m2-26) {};							\& \\
			%------------------------------------------------------------------------------------------------------------------------------------------------
		};
		
		\draw[->] (m2-02) -- (m2-12);
		%\draw[dspconn] (m2-10) -- (m2-11);
		\draw[dspconn] (m2-11) -- (m2-12);
		\draw[dspconn] (m2-12) -- (m2-13);
		\draw[dspconn] (m2-13) -- (m2-14);
		\draw[dspconn] (m2-14) -- (m2-15);
		\draw[dspline] (m2-15) -- (m2-16);
		\draw[dspconn] (m2-16) -- (m2-17); 
		\draw[dspconn] (m2-17) -- (m2-18);
		\draw[dspconn] (m2-18) -- (m2-19);
		\draw[dspline] (m2-16) -- (m2-26);
		\draw[dspline] (m2-26) -- (m2-23);
		\draw[dspconn] (m2-23) -- (m2-13);
		\pgfplotsset{width=2.25cm,height=2.25cm,xmin=0.1,xmax=1000000,ymin=0.0001,ymax=10}
		\begin{loglogaxis}[
				at={($(m2-11) + (-9,-9)$)},
				ticks=none,
				axis x line*=bottom,
				axis y line*=left
			 ]
			\addplot[domain=1:100000]  {(60*x+10000)/(x*x + 60*x+10000)};
		\end{loglogaxis}
		\pgfplotsset{width=2.25cm,height=2.25cm,xmin=0.1,xmax=1000000,ymin=0.0001,ymax=10}
		\begin{loglogaxis}[
				at={($(m2-17) + (-9,-9)$)},
				ticks=none,
				axis x line*=bottom,
				axis y line*=left
			 ]
			\addplot[domain=1:100000]  {(60*x+10000)/(x*x + 60*x+10000)};
		\end{loglogaxis}
		
		\coordinate (m0-10x) at (m1-10 |- m0-11); % If (m0-10) is used, there is slight misalignment (not sure why).
		\coordinate (m2-10x) at (m1-10 |- m2-11); % If (m0-10) is used, there is slight misalignment (not sure why).
		\draw[dspconn] (m0-10x) -- (m0-11);
		\draw[dspconn] (m2-10x) -- (m2-11);
		\draw[dspline] (m0-10x) -- (m1-10);
		\draw[dspline] (m1-10) -- (m2-10x);
		\node[dspnodeopen,dsp/label=left] (r) at ($(m1-10) + (-0.5cm, 0)$) {$r(t)$};
		\draw[dspline] (r) -- (m1-10);
		
		\node[coordinate] (g-y2) at ($(m2-19) + (4cm,0)$) {};
		\coordinate (g-y1) at (g-y2 |- m1-15);
		\coordinate (g-y0) at (g-y2 |- m0-13);
		\node[dspnodeopen,dsp/label=right] (y1) at (m2-19 |- m1-15) {$y_2[k]$};
		\node[dspnodeopen,dsp/label=right] (y0) at (m2-19 |- m0-13) {$y_1[k]$};
		
		\draw[dspconn] (m0-13) -- (y0);
		\draw[dspconn] (m1-15) -- (y1);
		
		\begin{axis}[
			at={($(r) + (-3cm,0)$)},
			anchor=center,
			width=6cm, height=3.75cm,
			anchor=center, 
			xmin=0, xmax=4,
			ymin=-100, ymax=300,
			axis x line=bottom, axis y line=left, axis line style={-},
			xticklabels={0,1,2,3,\SI{4}{\second}}, xtick={0,1,2,3,4},
			yticklabels={, 0, \SI{300}{\micro\volt}}, ytick={-100, 0, 300}
			]
			\addplot[solid,black] table [x=t, y=r, col sep=comma] {data/comparison-r.csv};
		\end{axis}
		
		\begin{axis}[
			at={(g-y0)},
			anchor=center,
			width=6cm, height=3.75cm,
			anchor=center, 
			xmin=0, xmax=4,
			ymin=-100, ymax=300,
			axis x line=none, axis y line=left, axis line style={-},
			xticklabels={0,1,2,3,\SI{4}{\second}}, xtick={0,1,2,3,4},
			yticklabels={, 0, \SI{300}{\micro\volt}}, ytick={-100, 0, 300}
			]
			\addplot[solid,black] table [x=t, y=y, col sep=comma] {data/comparison-y0.csv};
		\end{axis}
		
		\begin{axis}[
			at={(g-y1)},
			anchor=center,
			width=6cm, height=3.75cm,
			anchor=center, 
			xmin=0, xmax=4,
			ymin=-100, ymax=300,
			axis x line=none, axis y line=left, axis line style={-},
			xticklabels={0,1,2,3,\SI{4}{\second}}, xtick={0,1,2,3,4},
			yticklabels={, 0, \SI{300}{\micro\volt}}, ytick={-100, 0, 300}
			]
			\addplot[solid,black] table [x=t, y=y, col sep=comma] {data/comparison-y1.csv};
		\end{axis}
		
		\begin{axis}[
			at={(g-y2)},
			anchor=center,
			width=6cm, height=3.75cm,
			anchor=center, 
			xmin=0, xmax=4,
			ymin=-100, ymax=300,
			axis x line=bottom, axis y line=left, axis line style={-},
			xticklabels={0,1,2,3,\SI{4}{\second}}, xtick={0,1,2,3,4},
			yticklabels={, 0, \SI{300}{\micro\volt}}, ytick={-100, 0, 300}
			]
			\addplot[solid,black] table [x=t, y=y, col sep=comma] {data/comparison-y2.csv};
		\end{axis}
		
	\end{tikzpicture}
	\end{center}
	\caption{A comparison between na\"{i}ve quantization (top), 10 times oversampled quantization (middle), and first order sigma delta modulation (bottom). The graphs on the right show the increasing quality of an \glsentryshort{EEG} signal \cite{Blankertz2007} sampled to a final rate of \SI{100}{\hertz} and quantized by Q with 5 bits by each scheme.}
	\label{fig:os-ns-compare}
\end{figure}
\end{landscape}

\section{Basic Structure}
\label{sec:in-bs}

The basic block diagram of a sigma delta modulator and nomenclature that will be used henceforth is now introduced. For brevity, the scope of this thesis is limited to sigma delta \gls{A/D} converters but the concepts are easily transferrable to the \gls{D/A} case. Modulators can be one of two main classes, \gls{DT} or \gls{CT}, referring to the nature of the \gls{LF}. The two types differ in the location of the \gls{S/H} block. \gls{CT} modulators allow higher sampling rates and lower power consumption than \gls{DT} types, but are more susceptible to power supply variations, clock jitter, and component nonidealities. In addition, the stability of a \gls{CT} sigma delta modulator is more difficult to analyze.

\subsection{Discrete-Time Modulator}
\label{sec:in-dtm}

\begin{figure}[h]
\noindent\makebox[\textwidth]{
	\centering
	% DT Sigma Delta Modulator
	\begin{tikzpicture}[ampersand replacement=\&,scale=0.68, every node/.style={scale=0.68}]
	
		% Place nodes using a matrix
		\matrix (m1) [row sep=2.5mm, column sep=5mm]
		{
			%------------------------------------------------------------------------------------------------------------------------
			\node[coordinate]								(m0-00) {};				\&
			\node[coordinate]								(m0-01) {};				\&
			\node[coordinate,label={above:\PulseHigh \ $OSR \cdot f_s$}]	(m0-02) {};				\& \\
			%------------------------------------------------------------------------------------------------------------------------
			\node[dspnodeopen,dsp/label=above]					(m1-00) {$r_0(t)$};			\&
			\node[dspsquare,label={above:AAF}]					(m1-01) {};				\&
			\node[dspsquare]								(m1-02) {S/H};			\&
			%\node[coordinate,label={above:$r[k]$}]				(m1-03) {};				\&
			\node[dspfilter]								(m1-04) {$H_0(z)$};		\&
			\node[coordinate]								(m1-05) {};				\&
			\node[coordinate]								(m1-07) {};				\& \\
			%------------------------------------------------------------------------------------------------------------------------
			\node[coordinate]								(m2-00) {};				\&
			\node[coordinate]								(m2-01) {};				\&
			\node[coordinate]								(m2-02) {};				\&
			\node[dspadder,label={below left:$-$}]				(m2-04) {};				\&
			\node[dspfilter]								(m2-05) {$H_1(z)$};		\&
			\node[dspsquare,label={below:Quantizer}]				(m2-07) {\RaisingEdge};		\&
			\node[dspnodefull,label={above:$y[k]$}]				(m2-08) {};				\&
			%\node[coordinate,label={above:$y[k]$}]				(m2-09) {};				\&
			\node[dspsquare,label={above:DRF}]					(m2-10) {};				\& 
			\node[dspfilter]								(m2-11) {$\downarrow OSR$};	\&
			\node[dspnodeopen,dsp/label=above]					(m2-12) {$y[m]$};			\& \\
			%------------------------------------------------------------------------------------------------------------------------
			\node[coordinate]								(m3-00) {};				\&
			\node[coordinate]								(m3-01) {};				\&
			\node[coordinate]								(m3-02) {};				\&
			\node[coordinate]								(m3-04) {};				\& 
			\node[coordinate]								(m3-05) {};				\& 
			\node[coordinate]								(m3-07) {};				\& 
			\node[coordinate]								(m3-08) {};				\& \\
			%\node[coordinate]								(m3-09) {};				\& \\
			%------------------------------------------------------------------------------------------------------------------------
		};
	
		%\node[draw,inner xsep=15pt,inner ysep=10pt,dashed,fit={($(m1-07.north)+(-0.5, 0.7)$) ($(m2-07.south)+(0.5, -0.6)$)},label={[align=center]above:Linear Model}] {};
		\node[draw,inner xsep=15pt,inner ysep=10pt,dashed,fit={($(m1-04.north west)+(-0.5, 0.3)$) ($(m2-05.south east)+(0.4, -0.5)$)},label=above:{Loop Filter $H(z)$}] {};

		\draw[->]		(m0-02) -- (m1-02);
		\draw[dspconn]	(m1-00) -- (m1-01);
		\draw[dspconn]	(m1-01) to node[midway,above] {$r(t)$} (m1-02);
		\draw[dspconn] 	(m1-02) to node[midway,above,xshift=-4pt] {$r[k]$} (m1-04);
		\draw[dspconn] 	(m1-04) -- (m2-04);
		\draw[dspline] 	(m2-05) -- (m2-07);
		%\draw[dspconn] 	($(m2-06.east)+(6pt, 0)$) -- (m2-07);
		\draw[dspline]	(m2-07) -- (m2-08);
		\draw[dspconn] 	(m2-08) -- (m2-10);
		\draw[dspline] 	(m2-08) -- (m3-08);
		\draw[dspline] 	(m3-08) -- (m3-02);
		\draw[dspline]	(m3-02) -- (m2-02);
		\draw[dspconn] 	(m2-02) -- (m2-04);
		\draw[dspconn] 	(m2-04) to node[midway,above] {$e[k]$} (m2-05);
		%\draw[dspconn] 	(m1-07) -- (m2-07);
		\draw[dspconn]	(m2-10) -- (m2-11);
		\draw[dspconn]	(m2-11) -- (m2-12);
		\draw[Gray, ->, out=45, in=105, looseness=0.85] ($(m1-02)+(1, 0.8)$) to node[above, xshift=-22pt] {$T(z)$} ($(m2-08)+(0.1, 0.8)$);
		\draw[Gray, ->, out=0, in=90, looseness=1] ($(m1-04)+(0.2, -0.6)$) to node[right, xshift=5pt] {$S(z)$} ($(m2-04)+(0.8, 0.75)$);
		
		\pgfplotsset{width=2.25cm,height=2.25cm,xmin=0.1,xmax=1000000,ymin=0.0001,ymax=10}
		\begin{loglogaxis}[
				at={($(m1-01) + (-9,-9)$)},
				ticks=none,
				axis x line*=bottom,
				axis y line*=left
			 ]
			\addplot[domain=1:100000]  {(60*x+10000)/(x*x + 60*x+10000)};
		\end{loglogaxis}
		\pgfplotsset{width=2.25cm,height=2.25cm,xmin=0.1,xmax=1000000,ymin=0.0001,ymax=10}
		\begin{loglogaxis}[
				at={($(m2-10) + (-9,-9)$)},
				ticks=none,
				axis x line*=bottom,
				axis y line*=left
			 ]
			\addplot[domain=1:100000]  {(60*x+10000)/(x*x + 60*x+10000)};
		\end{loglogaxis}
	\end{tikzpicture}}
	\caption{The basic block diagram of a \glsentryshort{DT} sigma delta \glsentryshort{A/D} converter.} \label{fig:basic-struct-dt}
\end{figure}

Consider the \gls{DT} modulator block diagram shown in \autoref{fig:basic-struct-dt}. The analog front-end includes the \gls{AAF} and \gls{S/H} block. This subsystem conditions the input signal $r_0(t)$ and samples it outside the loop to produce \gls{DT} signal $r[k]$. In the modulator loop, the 2-input, 1-output \gls{LF} operates on $r[k]$ and the feedback signal, producing intermediate signal $u[k]$ with shaped noise. Then, $u[k]$ undergoes quantization producing discrete-value output $y[k]$. The quantizer output is fed back to the \gls{LF} and also passed along. The final subsystem filters the signal from the shaped noise in the digital domain with a downsampling \gls{DRF} to yield the final digital output $y[m]$.

From a control systems perspective, there are a couple of transfer functions that will be used to analyze and synthesize loop filters. The sensitivity function \gls{S}, where \gls{sorz}$=z$, is known as the \gls{NTF} of the modulator because it shows how the quantization error is filtered in the linearized model. The \gls{NTF} is conceptualized as a transfer function from an additive disturbance entering at the quantizer to the output $y$. The complementary sensitivity function \gls{T} is known as the \gls{STF} of the modulator and shows how the signal is transformed by the modulator loop. It is conceptualized as shown in \autoref{fig:basic-struct-dt} from input $r$ to output $y$.

\subsection{Continuous-Time Modulator}
\label{sec:in-ctm}


\begin{figure}[h]
\noindent\makebox[\textwidth]{
	\centering
	% CT Sigma Delta Modulator
	\begin{tikzpicture}[ampersand replacement=\&,scale=0.68, every node/.style={scale=0.68}]
	
		% Place nodes using a matrix
		\matrix (m1) [row sep=2.5mm, column sep=5mm]
		{
			%------------------------------------------------------------------------------------------------------------------------
			\node[dspnodeopen,label={above:$r(t)$}]				(m1-02) {};				\&
			\node[coordinate]								(m1-03) {};				\&
			\node[dspfilter]								(m1-04) {$H_0(s)$};		\&
			\node[coordinate]								(m1-05) {};				\&
			\node[coordinate,label={above:\PulseHigh \ $OSR \cdot f_s$}]	(m1-06) {};				\&
			\node[coordinate]								(m1-07) {};				\& \\
			%------------------------------------------------------------------------------------------------------------------------
			\node[coordinate]								(m2-02) {};				\&
			\node[coordinate]								(m2-03) {};				\&
			\node[dspadder,label={below left:$-$}]				(m2-04) {};				\&
			\node[dspfilter]								(m2-05) {$H_1(s)$};		\&
			\node[dspsquare]								(m2-06) {S/H};			\&
			\node[dspsquare,label={below:Quantizer}]				(m2-07) {\RaisingEdge};		\&
			\node[dspnodefull,label={above:$y[k]$}]				(m2-08) {};				\&
			%\node[coordinate,label={above:$y[k]$}]				(m2-09) {};				\&
			\node[dspsquare,label={above:DRF}]					(m2-10) {};				\& 
			\node[dspfilter]								(m2-11) {$\downarrow OSR$};	\&
			\node[dspnodeopen,dsp/label=above]					(m2-12) {$y[m]$};			\& \\
			%------------------------------------------------------------------------------------------------------------------------
			\node[coordinate]								(m3-02) {};				\&
			\node[coordinate]								(m3-03) {};				\&
			\node[coordinate]								(m3-04) {};				\& 
			\node[coordinate]								(m3-05) {};				\& 
			\node[dspadc]								(m3-06) {$P(s)$};			\& 
			\node[coordinate]								(m3-07) {};				\& 
			\node[coordinate]								(m3-08) {};				\& \\
			%\node[coordinate]								(m3-09) {};				\& \\
			%------------------------------------------------------------------------------------------------------------------------
		};
	
		%\node[draw,inner xsep=15pt,inner ysep=10pt,dashed,fit={($(m1-07.north)+(-0.5, 0.7)$) ($(m2-07.south)+(0.5, -0.6)$)},label={[align=center]above:Linear Model}] {};
		\node[draw,inner xsep=15pt,inner ysep=10pt,dashed,fit={($(m1-04.north west)+(-0.5, 0.3)$) ($(m2-05.south east)+(0.4, -0.5)$)},label=above:{Loop Filter $H(s)$}] {};

		\draw[dspconn] 	(m1-02) -- (m1-04);
		\draw[dspconn] 	(m1-04) -- (m2-04);
		\draw[->]		(m1-06) -- (m2-06);
		\draw[dspconn] 	(m2-05) to node[midway,above,xshift=5pt] {$u(t)$} (m2-06);
		\draw[dspconn]	(m2-06) to node[midway,above,xshift=-7pt] {$u[k]$} (m2-07);
		\draw[dspconn] 	($(m2-06.east)+(6pt, 0)$) -- (m2-07);
		\draw[dspline]	(m2-07) -- (m2-08);
		\draw[dspconn] 	(m2-08) -- (m2-10);
		\draw[dspline] 	(m2-08) -- (m3-08);
		\draw[dspconn] 	(m3-08) -- (m3-06);
		\draw[dspline]	(m3-06) -- (m3-03);
		\draw[dspline]	(m3-03) -- (m2-03);
		\draw[dspconn] 	(m2-03) -- (m2-04);
		\draw[dspconn] 	(m2-04) to node[midway,above] {$e(t)$} (m2-05);
		%\draw[dspconn] 	(m1-07) -- (m2-07);
		\draw[dspconn]	(m2-10) -- (m2-11);
		\draw[dspconn]	(m2-11) -- (m2-12);
		\draw[Gray, ->, out=30, in=105, looseness=0.85] ($(m1-02)+(0, 0.8)$) to node[below, xshift=-22pt] {$T(s)$} ($(m2-08)+(0.1, 0.8)$);
		%\draw[RedOrange, ->, out=-45, in=135, looseness=1] ($(m1-07)+(0.35, 0.25)$) to node[above, xshift=5pt] {$S(s)$} ($(m2-09)+(0, 0.75)$);
		%\draw[Gray, ->, out=-45, in=135, looseness=1] ($(m1-02)+(-0.4, -0.3)$) to node[below, xshift=5pt] {$S(z)$} ($(m2-04)+(0.7, 0.7)$);
		\draw[Gray, ->, out=0, in=90, looseness=1] ($(m1-04)+(0.2, -0.6)$) to node[right, xshift=5pt] {$S(z)$} ($(m2-04)+(0.8, 0.75)$);
		
		\pgfplotsset{width=2.25cm,height=2.25cm,xmin=0.1,xmax=1000000,ymin=0.0001,ymax=10}
		\begin{loglogaxis}[
				at={($(m2-10) + (-9,-9)$)},
				ticks=none,
				axis x line*=bottom,
				axis y line*=left
			 ]
			\addplot[domain=1:100000]  {(60*x+10000)/(x*x + 60*x+10000)};
		\end{loglogaxis}
	\end{tikzpicture}}
	\caption{The basic block diagram of a \glsentryshort{CT} sigma delta \glsentryshort{A/D} converter.} \label{fig:basic-struct-ct}
\end{figure}

For the \gls{CT} class of modulators, consider the structure of \autoref{fig:basic-struct-ct}. It is similar to the \gls{DT} case except the \gls{LF} operates directly on analog input $r(t)$ in the \gls{CT} domain and sampling is done inside the loop. The \gls{AAF} is no longer necessary in most cases because the \gls{LF} precedes the sampling block. It generally has high gain for in-band signals and implicitly attenuates components of the signal that would result in aliasing. Finally, signal $y[k]$ must undergo \gls{D/A} conversion during feedback, modelled with the pulse transfer function $P(s)$. 

The \gls{NTF} and \gls{STF} of a \gls{CT} sigma delta modulator are more difficult to define because they are transfer functions involving both \gls{CT} and \gls{DT} signals. The \gls{DT} equivalence principle states that there is a \gls{DT} modulator model that exactly describes the \gls{CT} design at the sampling instants, because the modulator is overall a sampled data system \cite[Sec. 3.2]{Ortmanns2005}. Thus, \gls{DT} transfer functions can be derived for this purpose. However, these equivalent transfer functions may be difficult to manipulate due to their dependence on $P(s)$. For the purposes of this analysis, the sampling block is omitted during design, causing \gls{S} and \gls{T} to be simplified as \gls{CT} (\gls{sorz}$=s$) transfer functions mapping $t(t) \rightarrow e(t)$ and $r(t) \rightarrow y(t)$, respectively.

\section{Loop Filter}
\label{sec:in-lf}

Together, quantization and noise shaping permit a coarser quantizer element to be used. A common design pattern is to use a high order ($n>2$)  \gls{LF} paired with a single-bit quantizer, which is advantageous from a circuit design perspective because a quantizer with just two levels is inherently linear. In addition, low order sigma delta loops often suffer from spurious tones \cite[Sec. 2.6.1]{Schreier1997}. Unfortunately, as \gls{LF} order is increased, the tendency of the loop to become unstable does as well. While first and second order designs are provably stable for DC inputs \cite{Hein1993}, high order filters require careful design to avoid instability. Ensuring stability while maintaining performance is a difficult task due to the presence of the highly nonlinear quantizer. The nonlinearity makes analysis complicated, a stable linear model does not imply a stable modulator while an unstable \gls{LF} can even result in a stable overall modulator, known as the chaotic type \cite{Risbo1994}.

The design of the noise shaping loop filter is the focus of this thesis. Modelling the loop filter as a 2-input 1-output system as shown in \autoref{sec:in-bs} allows the \gls{NTF} to be determined by $H_1(\lambda)$ alone while the \gls{STF} can be modified independently with filter $H_0(\lambda)$, without loss of generality:

\begin{align}
	S(\lambda) &= \frac{1}{1 + H_1(\lambda)} \label{eq:s} \\
	T(\lambda) &= \frac{H_0(\lambda)H_1(\lambda)}{1 + H_1(\lambda)}. \label{eq:t}
\end{align}

A desirable \gls{NTF} is one that results in a stable linear model, rejects noise in the signal band as much as possible, and has low gain in the out-of-band region to promote stability. The \gls{STF} is less important as $H_0(\lambda)$ can be interpreted as a pre-filter to modify the \gls{STF} and obtain unity gain in the signal band.

For a first order modulator, a pure integrator can be used as the loop filter $H_0(\lambda)$. For higher orders, it is common to choose a prototype \gls{NTF} from a family of filters. For example, the popular Delta Sigma Toolbox for MATLAB \cite[Appx. B]{Schreier1997} uses a Chebyshev type II filter for this purpose. The poles of the \gls{NTF} greatly affect the stability of the loop, so the traditional design procedure involves extensive simulation under varying input conditions to ensure instability is unlikely during normal operation. Once unstable, the filter states must be reset in order to restore correct operation. Various schemes have been used to detect the onset of instability \cite{Wong2004} and avoid it with gain scaling \cite{Sooch1989}, internal linear feedback \cite{Moussavi1994}, and automatic resetting schemes \cite{Eynde1991}.

\section{Related Works}
\label{sec:in-rw}

Optimization techniques have been used to design \gls{NTF}s with more degrees of freedom than those made with a single filter prototype. A simple example is that from \cite[Sec. 4.3]{Schreier1997}, where the zeros of the prototype \gls{NTF} are optimized by approximating the integral of the \gls{NTF} in the pass-band, then minimizing it analytically by equating its derivative to zero. The procedure results in an optimal spreading of zeros across the signal bandwidth to reduce in-band quantization noise for the given \gls{NTF} poles. One of the first optimization-based approaches to \gls{NTF} design was the \gls{CLANS} methodology that minimizes \gls{pq} under the white quantization noise assumption \cite{Kenney1988}. This is done using nonlinear programming to find stable \gls{NTF} pole locations that minimize the accumulation of quantization error subject to some stability and realizability constraints.

Using the principles from \gls{Hinf} control and its associated \gls{LMI} methods, one can define the quantizer as a very simple feedthrough plant and introduce weighting filters on the feedback error signal \gls{e}, loop filter output \gls{u}, and quantizer output \gls{y} to design the loop filter as a controller for various performance and stability constraints \cite{Oberoi2004}. However, the system is bound to the order of the augmented plant and relies on the designer to choose the weights. Choosing weighting filters that are ideal is almost as difficult a task as just choosing the prototype \gls{NTF} directly. Despite this, if a known \gls{AAF} or \gls{DRF} is specified in advance, it may be used as a sort of weighting filter and a case-optimal \gls{LF} can be designed around it \cite{Ohno2017b}. Applications for this method could be optimizing the \gls{STF} of an audio \gls{D/A} converter to a psychoacoustic model or making use of existing filters in the signal path.

More recently, the \gls{GKYP} lemma has been applied to sigma delta modulator design. The lemma provides a link between a finite frequency domain inequality, such as specifications on the \gls{NTF} gain, and a linear matrix inequality condition, which can be solved using efficient interior point methods. Using this lemma, the techniques of \gls{Hinf} control can be applied to a transfer function but restricted to a specific frequency band. This eliminates the need for weighting filters that specify a select band of interest. Unfortunately, the problem becomes non-convex and hard to solve if both poles and zeros are to be optimized simultaneously as is the case with an \gls{IIR} filter. As a workaround, the \gls{NTF} poles may be fixed to a prototype design and just the zeros optimized \cite{Osqui2007}, similar to what was described at the start of this Section. Alternatively, a \gls{FIR} \gls{NTF} form may be assumed \cite{Nagahara2012, Tariq2016} then possibly converted to \gls{IIR} form using approximate methods such as least-squares or Yule-Walker \cite{Tariq2017}. Aside from the large delay introduced, the \gls{FIR} form is not the optimal choice according to \cite{Derpich2008}. Iterative methods have also shown promise in providing a workaround to the non-convexity associated with direct \gls{IIR} design. A survey of some optimization methods for sigma delta modulator design is presented in \cite{Callegari2015} while \autoref{tab:related} summarizes the major contributions of each and the differences between them.

\begin{table}
\begin{threeparttable}
%\noindent\makebox[\textwidth]{
	\caption{A comparison of some recent work on sigma delta modulator design as a control optimization problem.} \label{tab:related}
	\begin{tabularx}{\textwidth}{X P{1.9cm} P{0.6cm} P{1.9cm} P{3.2cm}}
	%\begin{tabularx}{\textwidth}{X P{1.8cm} P{1.9cm} P{0.7cm} P{3.2cm}}
		\toprule
		\textbf{Reference} & \textbf{Optimized norms} & \textbf{\gls{NTF} Type} & \textbf{Performance goal} & \textbf{Stability criteria (see \autoref{ch:Stability})} \\
		\midrule
		Oberoi (2004) \cite{Oberoi2004} & \gls{Hinf}, \gls{H2}, \gls{l1} &\gls{IIR} &  Weighting filters & Uses heuristic bounds on \gls{Hinf}, \gls{H2} norms \\
		Osqui \& Megretski (2007) \cite{Osqui2007} & \gls{Hinf} & \gls{IIR}\tnote{1} & \gls{GKYP} lemma & Not reported \\
		Nagahara \& Yamamoto (2012) \cite{Nagahara2012} & \gls{Hinf} & \gls{FIR} & \gls{GKYP} lemma & \gls{l1} criterion mentioned, but Lee criterion used in design \\
		Li, Yu, \& Gao (2014) \cite{Li2014} & \gls{Hinf} & \gls{IIR} & \gls{GKYP} lemma & Lee criterion \\
		Tariq \& Ohno (2016) \cite{Tariq2016} & \gls{Hinf}, \gls{H2}, \gls{l1} & \gls{FIR} & Weighting filters & \gls{l1} criterion mentioned but Lee criterion used in design \\
		\bottomrule
	\end{tabularx}
	\begin{tablenotes}
		\item[1] Only the zeros of the \gls{IIR} filter are optimized.
	\end{tablenotes}
%	}
\end{threeparttable}
\end{table}

\section{Objectives}
\label{sec:in-obj}

The objective of this thesis was to develop a systematic method of designing sigma delta \gls{A/D} converters for the recording of bio-signals. Many bio-signals are low-pass signals with reasonably low Nyquist frequencies. The designs presented in this Thesis are not usable only for only this class of signal but a specific bio-signal is used for the examples in \autoref{ch:Examples}. The goal of this method was to:

\begin{enumerate}
	\item Model the nonlinear system accurately in a way that allows analysis of existing designs.
	\item Reduce dependence on post-design simulation by supporting as many stability criteria as possible to have \emph{a priori} indicators of stability.
	\item Provide a way to design guaranteed stable sigma delta modulators in a way that minimizes conservatism.
\end{enumerate}

\section{Contributions}
\label{sec:in-contrib}

The contributions in this Thesis are related to both the theory of sigma delta loop filter design and the application of this theory to produce usable designs with acceptable performance.

\begin{enumerate}
	\item (Application) Development of an algorithm that unites \gls{Hinf}, \gls{H2}, and \gls{l1} stability criteria with the \gls{GKYP} performance goal supporting both \gls{IIR} and \gls{FIR} \gls{NTF}s. As seen in \autoref{tab:related}, the existing approaches that allowed all three of these stability criteria either required weighting filters for performance goals or only supported \gls{FIR} \gls{NTF}s.
	\item (Theory) Extending the \gls{LMI} system used in \cite{Li2014} to be compatible with constraints placed on the \gls{STF}, quantizer input signal, and robustness of the closed-loop system against quantizer gain. \label{it:ext-lmi}
	\item (Application) Applying a more rigorous iterative procedure used to solve the quadratic matrix inequalities than that used in \cite{Li2014} allowing guaranteed termination. 
	\item (Theory) Modelling the quantizer gain as an uncertainty and using the additional constraint from (\ref{it:ext-lmi}) to enforce stability for a range of quantizer gains.
	\item (Application) Presenting a proof-of-concept using this work to directly design a sigma delta modulator with a \gls{CT} loop filter.
\end{enumerate}

\section{Organization of this Thesis}
\label{sec:in-org}

Having established some background on the workings and nomenclature of a sigma delta modulator, \autoref{ch:Modelling} expands on this to show modifications to the general sigma delta model based on control theory that will permit it to be used in an optimization framework. In \autoref{ch:Stability}, various stability criteria are introduced, ranging from heuristics to sufficient conditions. Their relative rigour and impact on performance is discussed. Following the discussion of the role of optimization in loop filter design, \autoref{ch:Optimization} bridges the Modelling and Stability chapters by introducing a \gls{SDP} framework that supports the aforementioned criteria. The total design process is discussed in \autoref{ch:Examples}, with emphasis on simulation results as well as an empirical study of the tradeoff between performance and stability when using this approach. Finally, \autoref{ch:Conclusions} concludes the thesis with some discussion about the merits and shortcomings of this method of sigma delta modulator design and possible directions for future work.

\endinput
